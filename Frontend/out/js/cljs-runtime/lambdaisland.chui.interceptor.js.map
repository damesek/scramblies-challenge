{"version":3,"sources":["lambdaisland/chui/interceptor.cljs"],"mappings":"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","names":["lambdaisland.chui.interceptor/throwable->ex-info","t","interceptor","stage","lambdaisland.glogi.log","cljs.core/identity","cljs.core.assoc","cljs.core.ex_info","cljs.core.merge","cljs.core.keyword","cljs.core.pr_str","cljs.core/type","cljs.core/ex-data","var_args","args__4870__auto__","len__4864__auto__","i__4865__auto__","argseq__4871__auto__","cljs.core/IndexedSeq","lambdaisland.chui.interceptor/try-stage","seq27005","G__27007","cljs.core/first","cljs.core/next","G__27008","G__27009","self__4851__auto__","ctx","args","temp__5802__auto__","f","cljs.core.get","e27025","obj","cljs.core.apply","lambdaisland.chui.util/thenable?","kitchen_async.promise.then","lambdaisland.chui.interceptor/execute*","err","G__27036","G__27026","G__27043","lambdaisland.chui.interceptor/into-queue","js/Error","xs","lambdaisland.chui.interceptor.into_queue","q","cljs.core.into","cljs.core/PersistentQueue","cljs.core.fnil","cljs.core/into","p__27050","map__27054","cljs.core/--destructure-map","lambdaisland.chui.interceptor/enter-1","queue","stack","cljs.core/peek","new-queue","cljs.core/pop","new-context","p__27057","map__27058","error","on-context","on-error","terminate?","resolve","and__4251__auto__","cljs.core/deref","G__27060","cljs.core.dissoc","cljs.core/seq","lambdaisland.chui.interceptor/execute","p__26247__auto__","kitchen-async.promise/promise-impl","_","lambdaisland.chui.interceptor/enqueue","interceptors","cljs.core.update_in","p__27074","map__27076","lambdaisland.chui.interceptor/ctx-summary","G__27078","cljs.core.map"],"sourcesContent":["(ns lambdaisland.chui.interceptor\n  \"Implementation of the interceptor pattern with the following properties\n\n  - Uses JS promises for asynchrony\n  - Allows enqueuing more interceptors in a :leave or :error stage (this will\n    effectively switch back to the :enter stage of processing until the queue is\n    empty again)\n  - Takes an optional :on-context callback, for progress updates\n  - Takes an optional :terminate? atom, for signaling that the process should be\n    terminated as soon as possible\"\n  (:require [kitchen-async.promise :as p]\n            [lambdaisland.chui.util :as util]\n            [lambdaisland.glogi :as log]))\n\n(defn- throwable->ex-info [t interceptor stage]\n  (log/warn :error-in-interceptor (assoc interceptor :stage stage) :exception t)\n  (ex-info (str \"Exception in interceptor \" (:name interceptor) \" during the \" stage \" stage.\")\n           (merge\n            {:stage stage\n             :interceptor (:name interceptor)\n             :exception-type (keyword (pr-str (type t)))\n             :exception t}\n            (ex-data t))\n           t))\n\n(declare execute*)\n\n(defn- try-stage\n  \"Try running a specific stage of the given interceptor.\n\n  Will catch exceptions and switch the context over to error handling by\n  removing the `::queue` and adding an `::error` key.\"\n  [stage interceptor ctx & args]\n  (log/fine :try-stage {:stage stage :interceptor interceptor})\n  (if-let [f (get interceptor stage)]\n    (try\n      (let [obj (apply f ctx args)]\n        (if (util/thenable? obj)\n          (-> obj\n              (p/then\n               execute*\n               (fn [err]\n                 (execute* (assoc ctx ::error (throwable->ex-info err interceptor stage))))))\n          (execute* obj)))\n      (catch :default t\n        (-> ctx\n            (assoc ::error (throwable->ex-info t interceptor stage))\n            execute*)))\n    (execute* ctx)))\n\n(defn into-queue\n  \"Add elements to a queue, setting up a new queue if no queue was provided.\"\n  ([xs]\n   (into-queue nil xs))\n  ([q xs]\n   ((fnil into #queue []) q xs)))\n\n(defn enter-1\n  \"Invoke the `:enter` stage of the next interceptor.\n\n  Pop the next interceptor off the queue, push it onto the stack, and run its\n  `:enter` stage if it has one. \"\n  [{::keys [queue stack] :as ctx}]\n  (let [interceptor (peek queue)\n        new-queue   (pop queue)\n        new-context (assoc ctx ::queue new-queue)]\n    (try-stage :enter interceptor new-context)))\n\n#_\n(defn leave-1\n  \"Invoke the `:leave` stage of the next interceptor.\n\n  Pop the next interceptor off the stack, and run its `:leave` stage if it has\n  one.\"\n  [{::keys [stack] :as ctx}]\n  (let [interceptor (peek stack)\n        new-stack   (pop stack)\n        new-context (assoc ctx ::stack new-stack)]\n    (try-stage :leave interceptor new-context)))\n\n#_\n(defn error-1\n  \"Invoke the `:error` stage of the next interceptor.\n\n  Pop the next interceptor off the stack, and run its `:enter` stage if it has\n  one.\"\n  [{::keys [stack error] :as ctx}]\n  (let [interceptor (peek stack)\n        new-stack   (pop stack)\n        new-context (assoc ctx ::stack new-stack)]\n    (try-stage :error interceptor new-context error)))\n\n\n(defn execute*\n  \"Modified interceptor chain, only processes the enter chain. Takes a context map\n  with a ::queue of interceptors to be executed. Other special values that can\n  be passed in as part of the context:\n\n  - `::on-context` a callback that gets called at every iteration with the new\n    context map. Useful for keeping track of progress. Note that `::on-context`\n    gets called on the *start* of every iteration. To get the final context see\n    `::resolve`/`::reject`.\n  - `::on-error` error handler, receives the context and the error, must return\n    a context\n  - `::terminate?` an atom which, when set to true, will short circuit the\n    process at the next possible occasion\n  - `::resolve` function that gets called with the final context map\"\n  [{::keys [queue stack error on-context on-error terminate? resolve] :as ctx}]\n  (log/trace :execute ctx)\n\n  (when on-context\n    (on-context ctx))\n\n  (cond\n    (and terminate? @terminate?) (resolve (assoc ctx ::terminated? true))\n    (and error on-error)         (recur (dissoc (on-error ctx error) ::error))\n    ;; (and error (seq stack))      (error-1 ctx)\n    (seq queue)                  (enter-1 ctx)\n    ;; (seq stack)                  (leave-1 ctx)\n    :else                        (resolve ctx)))\n\n(defn execute [ctx]\n  (p/promise [resolve _]\n    (execute* (assoc ctx ::resolve resolve))))\n\n(defn enqueue\n  \"Enqueue interceptors.\n\n  Add interceptors to the context's FIFO queue.\"\n  [ctx interceptors]\n  (update-in ctx [::queue] into-queue interceptors))\n\n(defn ctx-summary\n  \"Take a context map, but rewrite the queue, stack and error to be more concise\n  for easy inspection.\"\n  [{::keys [queue stack error] :as ctx}]\n  (cond-> (dissoc ctx ::queue ::stack ::error)\n    (some? queue)\n    (assoc :queue (into-queue (map :name queue)))\n    (some? stack)\n    (assoc :stack (map :name stack))\n    (some? error)\n    (assoc :error (dissoc (ex-data error) :exception))))\n"]}
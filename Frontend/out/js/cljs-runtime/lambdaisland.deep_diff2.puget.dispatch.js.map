{"version":3,"sources":["lambdaisland/deep_diff2/puget/dispatch.cljc"],"mappings":";AAUA,AAAA;;;;;;wDAAA,gEAAAA,xHAAME;AAAN,AAAA,IAAAD,WAAA,AAAA;AAAA,AAAA,QAAAA;KAAA;AAAA,OAAAC,oFAAA,CAAA,UAAA;;;;AAAA,IAAAC,yBAAA;AAAA,AAAA,IAAAC,0BAAA,AAAA;AAAA,AAAA,IAAAC,wBAAA;;AAAA,AAAA,GAAA,CAAAA,wBAAAD;AAAA,AAAA,AAAAD,4BAAA,CAAA,UAAAE;;AAAA,eAAA,CAAAA,wBAAA;;;;AAAA;;;;AAAA,IAAAC,uBAAA,KAAAC,qBAAA,AAAAJ,6BAAA,KAAA,IAAA;AAAA,AAAA,OAAAD,2FAAA,CAAA,UAAA,MAAA,CAAA,UAAA,MAAAI;;;;;AAAA,CAAA,sFAAA,tFAAMJ,iGAKFa;AALJ,AAAA,GAMU,AAACC,4BAAYD;AANvB;AAAA,AAAA,MAAA,KAAAP,MAAA;;;AAOG,IAAMS,aAAW,AAACC,+CAAOC,qBAAKJ;uCAA9B,nCACMK;AADN,AAEE,GAAM,AAACC,uBAAOJ;AAAd,AACE,MAAO,iFAAA,2CAAA,wDAAA,iFAAA,rQAACK,gDAAQF;;AADlB;;AAGA,GAAI,6CAAA,7CAACG,iDAAI,AAACC,gBAAMP;AACd,OAACN,gBAAMM;;AACP,+DACGQ;AADH,AAEE,sBAAA,WAAAC,1BAACC;AAAD,AAAO,QAAAD,iDAAAA,oDAAAA,LAAGD,gCAAAA;GAAGR;;;;;AAhBtB,AAAA,CAAA,6FAAA,7FAAMf,wGAiBF0B,EAAEC,EAAIC;AAjBV,AAkBG,OAACC,oFAAe,AAACC,mDAAMJ,EAAEC,EAAEC;;;AAlB9B;AAAA,CAAA,0EAAA,WAAArB,rFAAMP;AAAN,AAAA,IAAAQ,WAAA,AAAAC,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;IAAAI,WAAA,AAAAF,gBAAAF;IAAAA,eAAA,AAAAG,eAAAH;AAAA,AAAA,IAAAK,qBAAA;AAAA,AAAA,OAAAA,wDAAAJ,SAAAG,SAAAJ;;;AAAA,CAAA,gFAAA,hFAAMP;;AAAN,AAoBA;;;;;wDAAA,xDAAM+B,wHAIHC;AAJH,AAKE,IAAMC,QAAM,6CAAA,7CAACC;AAAb,AACE,gFACGX;AADH,AAEE,aAAA,AAAAY,TAAMC,yBAAQH;AAAd,AACE,GAAI,AAACI,0BAAUD,OAAOb;AACpB,OAACe,4CAAIF,OAAOb;;AACZ,IAAMgB,IAAE,CAACP,yCAAAA,4CAAAA,LAAST,wBAAAA;AAAlB,AACE,AAACiB,mDAAMP,MAAMQ,gBAAMlB,EAAEgB;;AACrBA;;;;AAIT;;;0DAAA,1DAAMG,4HAEHC;AAFH,AAGE,kFAAYC;AAAZ,AACE,OAACnB,eAAK,WAAAoB;AAAA,AAAA,IAAAC,aAAAD;kBAAA,AAAAE,4CAAAD,WAAA,IAAA,zEAAME;cAAN,AAAAD,4CAAAD,WAAA,IAAA,rEAAYG;AAAZ,AACE,oBAAM,CAACD,4CAAAA,mDAAAA,TAAMJ,+BAAAA;AAAb,AACEK;;AADF;;GAEFN","names":["var_args","G__37759","lambdaisland.deep-diff2.puget.dispatch/chained-lookup","args-arr__4885__auto__","len__4864__auto__","i__4865__auto__","argseq__4886__auto__","cljs.core/IndexedSeq","js/Error","seq37755","G__37756","cljs.core/first","cljs.core/next","G__37757","self__4851__auto__","dispatchers","cljs.core/sequential?","candidates","cljs.core.remove","cljs.core/nil?","no-chain-lookup-provided-message","cljs.core/empty?","cljs.core.ex_info","cljs.core._EQ_","cljs.core/count","t","p1__37749#","cljs.core/some","a","b","more","lambdaisland.deep_diff2.puget.dispatch.chained_lookup","cljs.core.list_STAR_","lambdaisland.deep-diff2.puget.dispatch/caching-lookup","dispatch","cache","cljs.core.atom","cljs.core/deref","memory","cljs.core/contains?","cljs.core.get","v","cljs.core.swap_BANG_","cljs.core/assoc","lambdaisland.deep-diff2.puget.dispatch/predicate-lookup","types","value","p__37777","vec__37779","cljs.core.nth","pred?","handler"],"sourcesContent":["(ns lambdaisland.deep-diff2.puget.dispatch\n  \"Dispatch functions take a `Class` argument and return the looked-up value.\n  This provides similar functionality to Clojure's protocols, but operates over\n  locally-constructed logic rather than using a global dispatch table.\n\n  A simple example is a map from classes to values, which can be used directly\n  as a lookup function.\"\n  (:require [clojure.string :as str]))\n\n;; ## Logical Dispatch\n(defn chained-lookup\n  \"Builds a dispatcher which looks up a type by checking multiple dispatchers\n  in order until a matching entry is found. Takes either a single collection of\n  dispatchers or a variable list of dispatcher arguments. Ignores nil\n  dispatchers in the sequence.\"\n  ([dispatchers]\n   {:pre [(sequential? dispatchers)]}\n   (let [candidates (remove nil? dispatchers)\n         no-chain-lookup-provided-message \"chained-lookup must be provided at least one dispatch function to try.\"]\n     (when (empty? candidates)\n       (throw (ex-info no-chain-lookup-provided-message\n                       {:causes #{:no-chained-lookup-provided}})))\n     (if (= 1 (count candidates))\n       (first candidates)\n       (fn lookup\n         [t]\n         (some #(% t) candidates)))))\n  ([a b & more]\n   (chained-lookup (list* a b more))))\n\n(defn caching-lookup\n  \"Builds a dispatcher which caches values returned for each type. This improves\n  performance when the underlying dispatcher may need to perform complex\n  lookup logic to determine the dispatched value.\"\n  [dispatch]\n  (let [cache (atom {})]\n    (fn lookup\n      [t]\n      (let [memory @cache]\n        (if (contains? memory t)\n          (get memory t)\n          (let [v (dispatch t)]\n            (swap! cache assoc t v)\n            v))))))\n\n;; Space for predicate-lookup. ClojureScript support\n#?(:cljs\n   (defn predicate-lookup\n     \"Look up a handler for a value based on a map from predicate to handler\"\n     [types]\n     (fn lookup [value]\n       (some (fn [[pred? handler]]\n               (when (pred? value)\n                 handler))\n             types))))\n\n;; ## Type Dispatch (Clojure)\n#?(:clj\n   (defn symbolic-lookup\n     \"Builds a dispatcher which looks up a type by checking the underlying lookup\n  using the type's _symbolic_ name, rather than the class value itself. This is\n  useful for checking configuration that must be created in situations where the\n  classes themselves may not be loaded yet.\"\n     [dispatch]\n     (fn lookup\n       [^Class t]\n       (dispatch (symbol (.getName t))))))\n\n#?(:clj\n   (defn- lineage\n     \"Returns the ancestry of the given class, starting with the class and\n  excluding the `java.lang.Object` base class.\"\n     [cls]\n     (take-while #(and (some? %) (not= Object %))\n                 (iterate #(when (class? %) (.getSuperclass ^Class %)) cls))))\n\n#?(:clj\n   (defn- find-interfaces\n     \"Resolves all of the interfaces implemented by a class, both direct (through\n  class ancestors) and indirect (through other interfaces).\"\n     [cls]\n     (let [get-interfaces (fn [^Class c] (.getInterfaces c))\n           direct-interfaces (mapcat get-interfaces (lineage cls))]\n       (loop [queue (vec direct-interfaces)\n              interfaces #{}]\n         (if (empty? queue)\n           interfaces\n           (let [^Class iface (first queue)\n                 implemented (get-interfaces iface)]\n             (recur (into (rest queue)\n                          (remove interfaces implemented))\n                    (conj interfaces iface))))))))\n\n#?(:clj\n   (defn inheritance-lookup\n     \"Builds a dispatcher which looks up a type by looking up the type itself,\n  then attempting to look up its ancestor classes, implemented interfaces, and\n  finally `java.lang.Object`.\"\n     [dispatch]\n     (fn lookup\n       [obj]\n       (let [t (class obj)]\n         (or\n          (some dispatch (lineage t))\n          (let [candidates (remove (comp nil? first)\n                                   (map (juxt dispatch identity)\n                                        (find-interfaces t)))\n                wrong-number-of-candidates-message \"%d candidates found for interfaces on dispatch type %s: %s\"]\n            (case (count candidates)\n              0 nil\n              1 (ffirst candidates)\n              (throw (ex-info (format wrong-number-of-candidates-message\n                                      (count candidates) t (str/join \", \" (map second candidates)))))))\n          (dispatch Object))))))\n"]}
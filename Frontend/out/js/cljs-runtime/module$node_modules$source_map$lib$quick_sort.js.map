{
"version":3,
"file":"module$node_modules$source_map$lib$quick_sort.js",
"lineCount":2,
"mappings":"AAAAA,cAAA,CAAA,6CAAA,CAAkE,QAAQ,CAACC,MAAD,CAAQC,OAAR,CAAgBC,MAAhB,CAAuBC,OAAvB,CAAgC,CA4B1GC,QAASA,KAAI,CAACC,GAAD,CAAMC,CAAN,CAASC,CAAT,CAAY,CACvB,IAAIC,KAAOH,GAAA,CAAIC,CAAJ,CACXD,IAAA,CAAIC,CAAJ,CAAA,CAASD,GAAA,CAAIE,CAAJ,CACTF,IAAA,CAAIE,CAAJ,CAAA,CAASC,IAHc,CA8BzBC,QAASA,YAAW,CAACJ,GAAD,CAAMK,UAAN,CAAkBC,CAAlB,CAAqBC,CAArB,CAAwB,CAK1C,GAAID,CAAJ,CAAQC,CAAR,CAAW,CAaT,IAAIC,EAAIF,CAAJE,CAAQ,CAEZT,KAAA,CAAKC,GAAL,CAnCKS,IAAKC,CAAAA,KAALC,CAgC6BL,CAhC7BK,CAAkBF,IAAKG,CAAAA,MAAL,EAAlBD,EAgCgCJ,CAhChCI,CAgC6BL,CAhC7BK,EAmCL,CAAsBJ,CAAtB,CASA,KARA,IAAIM,MAAQb,GAAA,CAAIO,CAAJ,CAAZ,CAQSO,EAAIR,CAAb,CAAgBQ,CAAhB,CAAoBP,CAApB,CAAuBO,CAAA,EAAvB,CACmC,CAAjC,EAAIT,UAAA,CAAWL,GAAA,CAAIc,CAAJ,CAAX,CAAmBD,KAAnB,CAAJ,GACEL,CACA,EADK,CACL,CAAAT,IAAA,CAAKC,GAAL,CAAUQ,CAAV,CAAaM,CAAb,CAFF,CAMFf,KAAA,CAAKC,GAAL,CAAUQ,CAAV,CAAc,CAAd,CAAiBM,CAAjB,CACQN,EAAJO,EAAQ,CAIZX,YAAA,CAAYJ,GAAZ,CAAiBK,UAAjB,CAA6BC,CAA7B,CAAgCS,CAAhC,CAAoC,CAApC,CACAX,YAAA,CAAYJ,GAAZ,CAAiBK,UAAjB,CAA6BU,CAA7B,CAAiC,CAAjC,CAAoCR,CAApC,CArCS,CAL+B,CAsD5CT,OAAQkB,CAAAA,SAAR,CAAoBC,QAAS,CAACjB,GAAD,CAAMK,UAAN,CAAkB,CAC7CD,WAAA,CAAYJ,GAAZ;AAAiBK,UAAjB,CAA6B,CAA7B,CAAgCL,GAAIkB,CAAAA,MAApC,CAA6C,CAA7C,CAD6C,CAhH2D;",
"sources":["node_modules/source-map/lib/quick-sort.js"],
"sourcesContent":["shadow$provide[\"module$node_modules$source_map$lib$quick_sort\"] = function(global,require,module,exports) {\n/* -*- Mode: js; js-indent-level: 2; -*- */\n/*\n * Copyright 2011 Mozilla Foundation and contributors\n * Licensed under the New BSD license. See LICENSE or:\n * http://opensource.org/licenses/BSD-3-Clause\n */\n\n// It turns out that some (most?) JavaScript engines don't self-host\n// `Array.prototype.sort`. This makes sense because C++ will likely remain\n// faster than JS when doing raw CPU-intensive sorting. However, when using a\n// custom comparator function, calling back and forth between the VM's C++ and\n// JIT'd JS is rather slow *and* loses JIT type information, resulting in\n// worse generated code for the comparator function than would be optimal. In\n// fact, when sorting with a comparator, these costs outweigh the benefits of\n// sorting in C++. By using our own JS-implemented Quick Sort (below), we get\n// a ~3500ms mean speed-up in `bench/bench.html`.\n\n/**\n * Swap the elements indexed by `x` and `y` in the array `ary`.\n *\n * @param {Array} ary\n *        The array.\n * @param {Number} x\n *        The index of the first item.\n * @param {Number} y\n *        The index of the second item.\n */\nfunction swap(ary, x, y) {\n  var temp = ary[x];\n  ary[x] = ary[y];\n  ary[y] = temp;\n}\n\n/**\n * Returns a random integer within the range `low .. high` inclusive.\n *\n * @param {Number} low\n *        The lower bound on the range.\n * @param {Number} high\n *        The upper bound on the range.\n */\nfunction randomIntInRange(low, high) {\n  return Math.round(low + (Math.random() * (high - low)));\n}\n\n/**\n * The Quick Sort algorithm.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n * @param {Number} p\n *        Start index of the array\n * @param {Number} r\n *        End index of the array\n */\nfunction doQuickSort(ary, comparator, p, r) {\n  // If our lower bound is less than our upper bound, we (1) partition the\n  // array into two pieces and (2) recurse on each half. If it is not, this is\n  // the empty array and our base case.\n\n  if (p < r) {\n    // (1) Partitioning.\n    //\n    // The partitioning chooses a pivot between `p` and `r` and moves all\n    // elements that are less than or equal to the pivot to the before it, and\n    // all the elements that are greater than it after it. The effect is that\n    // once partition is done, the pivot is in the exact place it will be when\n    // the array is put in sorted order, and it will not need to be moved\n    // again. This runs in O(n) time.\n\n    // Always choose a random pivot so that an input array which is reverse\n    // sorted does not cause O(n^2) running time.\n    var pivotIndex = randomIntInRange(p, r);\n    var i = p - 1;\n\n    swap(ary, pivotIndex, r);\n    var pivot = ary[r];\n\n    // Immediately after `j` is incremented in this loop, the following hold\n    // true:\n    //\n    //   * Every element in `ary[p .. i]` is less than or equal to the pivot.\n    //\n    //   * Every element in `ary[i+1 .. j-1]` is greater than the pivot.\n    for (var j = p; j < r; j++) {\n      if (comparator(ary[j], pivot) <= 0) {\n        i += 1;\n        swap(ary, i, j);\n      }\n    }\n\n    swap(ary, i + 1, j);\n    var q = i + 1;\n\n    // (2) Recurse on each half.\n\n    doQuickSort(ary, comparator, p, q - 1);\n    doQuickSort(ary, comparator, q + 1, r);\n  }\n}\n\n/**\n * Sort the given array in-place with the given comparator function.\n *\n * @param {Array} ary\n *        An array to sort.\n * @param {function} comparator\n *        Function to use to compare two items.\n */\nexports.quickSort = function (ary, comparator) {\n  doQuickSort(ary, comparator, 0, ary.length - 1);\n};\n\n};"],
"names":["shadow$provide","global","require","module","exports","swap","ary","x","y","temp","doQuickSort","comparator","p","r","i","Math","round","pivotIndex","random","pivot","j","q","quickSort","exports.quickSort","length"]
}
